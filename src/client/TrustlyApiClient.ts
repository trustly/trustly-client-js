


import { java, JavaObject, S } from "jree";




export  class TrustlyApiClient extends JavaObject implements java.io.Closeable {

  private static readonly STATIC_REGISTERED_CLIENTS:  java.util.List<TrustlyApiClient> | null = new  java.util.ArrayList();

  private static readonly AVAILABLE_HTTP_REQUESTERS:  HttpRequesterLoader[] | null =  [
    new  ApacheHttpClient5HttpRequesterLoader(),
    new  ApacheHttpClient4HttpRequesterLoader(),
    new  ApacheHttpClient3HttpRequesterLoader(),
    new  JavaUrlConnectionHttpRequesterLoader()
  ];

  private static getFirstAvailableHttpRequester():  HttpRequester | null {

    let  foundHttpRequester: HttpRequester = null;
    for (let loader of TrustlyApiClient.AVAILABLE_HTTP_REQUESTERS) {

      foundHttpRequester = loader.create();
      if (foundHttpRequester !== null) {
        break;
      }
    }

    if (foundHttpRequester === null) {
      throw new  java.lang.IllegalStateException("Could not find a suitable http requester factory");
    }

    return foundHttpRequester;
  }

  public static NotificationMeta =  class NotificationMeta<D extends IFromTrustlyRequestData> extends JavaObject {

    protected dataClass: java.lang.Class<D> | null;
    protected listeners: java.util.List<NotificationEvent<D>> | null = new  java.util.ArrayList();
  };


  private readonly settings:  TrustlyApiClientSettings | null;

  private readonly objectMapper:  ObjectMapper | null = new  ObjectMapper();
  private readonly objectFactory:  JsonRpcFactory | null = new  JsonRpcFactory();
  private readonly signer:  JsonRpcSigner | null;
  private readonly validator:  JsonRpcValidator | null = new  JsonRpcValidator();
  private readonly httpRequester:  HttpRequester | null;

  private readonly onNotification:  java.util.Map<string, TrustlyApiClient.NotificationMeta< IFromTrustlyRequestData>> | null = new  java.util.HashMap();

  public getSettings():  TrustlyApiClientSettings | null {
    return this.settings;
  }

  public constructor(settings: TrustlyApiClientSettings| null);

  public constructor(settings: TrustlyApiClientSettings| null, signer: JsonRpcSigner| null);

  public constructor(settings: TrustlyApiClientSettings| null, httpRequester: HttpRequester| null);

  public constructor(settings: TrustlyApiClientSettings| null, signer: JsonRpcSigner| null, httpRequester: HttpRequester| null);
    public constructor(...args: unknown[]) {
		switch (args.length) {
			case 1: {
				const [settings] = args as [TrustlyApiClientSettings];


    this(settings, new  DefaultJsonRpcSigner(new  Serializer(), settings), TrustlyApiClient.getFirstAvailableHttpRequester());
  

				break;
			}

			case 2: {
				const [settings, signer] = args as [TrustlyApiClientSettings, JsonRpcSigner];


    this(settings, signer, TrustlyApiClient.getFirstAvailableHttpRequester());
  

				break;
			}

			case 2: {
				const [settings, httpRequester] = args as [TrustlyApiClientSettings, HttpRequester];


    this(settings, new  DefaultJsonRpcSigner(new  Serializer(), settings), httpRequester);
  

				break;
			}

			case 3: {
				const [settings, signer, httpRequester] = args as [TrustlyApiClientSettings, JsonRpcSigner, HttpRequester];


    super();
this.settings = settings;
    this.signer = signer;
    this.httpRequester = httpRequester;

    TrustlyApiClient.STATIC_REGISTERED_CLIENTS.add(this);
  

				break;
			}

			default: {
				throw new java.lang.IllegalArgumentException(S`Invalid number of arguments`);
			}
		}
	}


  public close():  void {
    TrustlyApiClient.STATIC_REGISTERED_CLIENTS.remove(this);
  }

  public static getRegisteredClients():  java.lang.Iterable<TrustlyApiClient> | null {
    return TrustlyApiClient.STATIC_REGISTERED_CLIENTS;
  }

  // Methods

  /**
   * Fetches the account ledger for the specified time period.
   * <p>
   * This report includes all the transactions (both incoming and outgoing transactions) that affect the merchant's Trustly account
   * balance.
   * <p>
   * Only settled transactions are included.
   */
  public accountLedger(request: AccountLedgerRequestData| null):  AccountLedgerResponseData | null {
    return this.sendRequest(request, AccountLedgerResponseData.class, "AccountLedger", null);
  }

  /**
   * This method is used by merchants to transfer money to their customer's bank accounts.
   * <p>
   * The merchant specifies the receiving bank account in {@link AccountPayoutRequestData#setAccountId}, which is a unique identifier
   * generated by Trustly.
   * <p>
   * The merchant can get the {@code AccountID} from {@link NotificationRequest}&lt;{@link AccountNotificationData}&gt; which is sent after
   * a {@link TrustlyApiClient#selectAccount} or {@link TrustlyApiClient#deposit} order has been completed.
   * <p>
   * Alternatively, the {@link TrustlyApiClient#registerAccount} method can be used to get the {@code AccountID}, if the merchant already
   * has the bank account details and want to register them in Trustly's system.
   * <p>
   * Funds must be transferred to the merchant's Trustly account before the payout can be made. No credit is given. To see how much money
   * you have on your Trustly account you can use the {@link TrustlyApiClient#balance} method or simply log in to the Trustly backoffice.
   * <p>
   * <h2>Example flow 1: SelectAccount + AccountPayout</h2>
   * <ol>
   *   <li>The merchant makes an API-call to {@link TrustlyApiClient#selectAccount} and redirects the end-user to {@link SelectAccountResponseData#getUrl()}.</li>
   *   <li>The end-user logs in to their bank and selects their bank account.</li>
   *   <li>Trustly sends an {@link NotificationRequest}&lt;{@link AccountNotificationData}&gt; to the merchant's system with an {@code AccountID} for the selected account.</li>
   *   <li>The merchant makes an API-call using this method with the {@link AccountPayoutRequestData#setAmount} and {@link AccountPayoutRequestData#setCurrency} to transfer.</li>
   *   <li>Trustly's API replies with a synchronous response to let the merchant know that the AccountPayout request was received.</li>
   *   <li>
   *     A {@link NotificationRequest}&lt;{@link PayoutConfirmationNotificationData}&gt; is sent to the merchant when the transfer has been confirmed.
   * <p>
   *     Note: this notification is not enabled by default. Please speak to your Trustly contact person if you want to have it enabled.
   * <p>
   *     If the payout fails, a {@link NotificationRequest}&lt;{@link CreditNotificationData}&gt; is sent (see more details <a href="https://eu.developers.trustly.com/doc/docs/accountpayout#failed-payouts">here</a>).
   *   </li>
   * </ol>
   *
   * <h2>Example flow 2: RegisterAccount + AccountPayout</h2>
   * <ol>
   *   <li>The merchant makes an API-call to {@link TrustlyApiClient#registerAccount} method with the recipient's bank account details.</li>
   *   <li>Trustly's {@link TrustlyApiClient#registerAccount} API responds with {@link RegisterAccountResponseData#getAccountId()} of the recipient's account.</li>
   *   <li>The merchant makes an API-call to this method with the {@link AccountPayoutRequestData#setAmount} and {@link AccountPayoutRequestData#setCurrency} to transfer.</li>
   *   <li>Trustly's API replies with a synchronous response to let the merchant know that the AccountPayout request was received.</li>
   *   <li>
   *     A {@link NotificationRequest}&lt;{@link PayoutConfirmationNotificationData}&gt; is sent to the merchant when the transfer has been confirmed.
   * <p>
   *     Note: this notification is not enabled by default. Please speak to your Trustly contact person if you want to have it enabled.
   * <p>
   *     If the payout fails, a {@link NotificationRequest}&lt;{@link CreditNotificationData}&gt; is sent (see more details <a href="https://eu.developers.trustly.com/doc/docs/accountpayout#failed-payouts">here</a>).
   * <p>
   *     An {@code AccountID} does not expire in Trustly's system, so it can be used for multiple AccountPayout requests.
   *   </li>
   * </ol>
   */
  public accountPayout(request: AccountPayoutRequestData| null):  AccountPayoutResponseData | null {
    return this.sendRequest(request, AccountPayoutResponseData.class, "AccountPayout", null);
  }

  /**
   * Approves a withdrawal prepared by the user. Please contact your integration manager at Trustly if you want to enable automatic approval
   * of the withdrawals.
   */
  public approveWithdrawal(request: ApproveWithdrawalRequestData| null):  ApproveWithdrawalResponseData | null {
    return this.sendRequest(request, ApproveWithdrawalResponseData.class, "ApproveWithdrawal", null);
  }

  /**
   * This method returns the current balance for all currencies available on the merchant's Trustly account.
   * <p>
   * ðŸš§ Please do not use this method more than once every 15 minutes.
   */
  public balance(request: BalanceRequestData| null):  BalanceResponseData | null {
    return this.sendRequest(request, BalanceResponseData.class, "Balance", null);
  }

  /**
   * For {@link TrustlyApiClient#charge} requests that have a future {@link ChargeRequestDataAttributes#setPaymentDate}, itâ€™s possible to
   * cancel the Charge up until 18:30 on the {@code PaymentDate}.
   * <p>
   * A {@code Charge} request that doesnâ€™t have any {@code PaymentDate} specified cannot be canceled. Itâ€™s also not possible to cancel a
   * {@code Charge} request if the {@code PaymentDate} is equal to the date when {@code Charge} request was sent.
   */
  public cancelCharge(request: CancelChargeRequestData| null):  CancelChargeResponseData | null {
    return this.sendRequest(request, CancelChargeResponseData.class, "CancelCharge", null);
  }

  /**
   * Charges a specific {@link ChargeRequestData#setAccountId} using direct debit.
   * <p>
   * A previously approved direct debit mandate must exist on the {@link ChargeRequestData#setAccountId} (see
   * {@link TrustlyApiClient#selectAccount} for details).
   */
  public charge(request: ChargeRequestData| null):  ChargeResponseData | null {
    return this.sendRequest(request, ChargeResponseData.class, "Charge", null);
  }

  /**
   * Denies a withdrawal prepared by the user.
   * <p>
   * Please contact your integration manager at Trustly if you want to enable automatic approval of the withdrawals.
   */
  public denyWithdrawal(request: DenyWithdrawalRequestData| null):  DenyWithdrawalResponseData | null {
    return this.sendRequest(request, DenyWithdrawalResponseData.class, "DenyWithdrawal", null);
  }

  /**
   * This method returns {@link DepositResponseData#getUrl()} where the end-user can make a payment from their bank account.
   * <p>
   * A typical Deposit flow is:
   * <ol>
   *   <li>The merchant sends a Deposit API call and receives a {@link DepositResponseData#getUrl()} back from Trustly's API.</li>
   *   <li>The merchant displays the {@link DepositResponseData#getUrl()} to the end-user (you can find more information about how to display the Trustly URL <a href="https://eu.developers.trustly.com/doc/docs/presentation-of-trustly-url">here</a>).</li>
   *   <li>The end-user selects their bank and completes the payment (in case the payment is not completed, a {@link NotificationRequest}&lt;{@link CancelNotificationData}&gt; is sent).</li>
   *   <li>
   *     Trustly sends a {@link NotificationRequest}&lt;{@link PendingNotificationData}&gt; to the {@link DepositRequestData#setNotificationUrl} when the end-user has completed the payment process,
   *     and a {@link NotificationRequest}&lt;{@link CreditNotificationData}&gt; is sent when the payment is confirmed.
   *     When the funds have settled, they will be credited to the merchant's Trustly account balance.
   *   </li>
   *   <li>
   *     (Optional) An {@link NotificationRequest}&lt;{@link AccountNotificationData}&gt; is sent to provide the merchant with more information about the account that was used to make the payment.
   * <p>
   *     This notification is not enabled by default, please reach out to your Trustly contact if you want to receive it.
   *   </li>
   *   <li>
   *     In case the Deposit fails, a {@link NotificationRequest}&lt;{@link DebitNotificationData}&gt; is sent
   *     (see more information <a href="https://eu.developers.trustly.com/doc/docs/deposit#failed-deposits">here</a>).
   *   </li>
   * </ol>
   */
  public deposit(request: DepositRequestData| null):  DepositResponseData | null {
    return this.sendRequest(request, DepositResponseData.class, "Deposit", null);
  }

  /**
   * This method returns the details of a payout (works for the {@link TrustlyApiClient#withdraw}, {@link TrustlyApiClient#accountPayout}
   * and {@link TrustlyApiClient#refund} methods).
   */
  public getWithdrawals(request: GetWithdrawalsRequestData| null):  GetWithdrawalsResponseData | null {
    return this.sendRequest(request, GetWithdrawalsResponseData.class, "GetWithdrawals", null);
  }

  /**
   * Refunds the customer on a previous {@link TrustlyApiClient#deposit} or {@link TrustlyApiClient#charge}.
   * <p>
   * The Refund will always be made to the same bank account that was used in the original payment.
   * <p>
   * You must have sufficient funds on your merchant account to make the refund. No credit is given. If the deposit has not yet been settled
   * when the refund request is received, the refund will be queued and executed once the money for the deposit has been received.
   */
  public refund(request: RefundRequestData| null):  RefundResponseData | null {
    return this.sendRequest(request, RefundResponseData.class, "Refund", null);
  }

  public createAccount(request: CreateAccountRequestData| null):  CreateAccountResponseData | null {
    return this.sendRequest(request, CreateAccountResponseData.class, "CreateAccount", null);
  }

  /**
   * Initiates a new order where the end-user can select and verify one of his/her bank accounts.
   * <p>
   * You can find more information about how to display the Trustly URL <a href="https://eu.developers.trustly.com/doc/docs/service-presentation">here</a>.
   * <p>
   * When the account has been verified an account notification is immediately sent to the
   * {@link SelectAccountRequestData#setNotificationUrl}.
   * <p>
   * A typical flow is:
   * <ol>
   *   <li>The merchant makes an API-call to this method and redirects the end-user to {@link SelectAccountResponseData#getUrl()}.</li>
   *   <li>The end-user selects his/her bank and completes the identification process.</li>
   *   <li>The end-user is redirected back to the merchant at {@link SelectAccountRequestDataAttributes#setSuccessUrl}. Note that the account might not be verified yet at this point.</li>
   *   <li>When the account is verified, Trustly sends an account notification to the merchant's system with information about the selected account</li>
   * </ol>
   */
  public selectAccount(request: SelectAccountRequestData| null):  SelectAccountResponseData | null {
    return this.sendRequest(request, SelectAccountResponseData.class, "SelectAccount", null);
  }

  /**
   * Registers and verifies the format of an account to be used in {@link TrustlyApiClient#accountPayout}.
   * <p>
   * A typical payout flow is:
   * <ol>
   *   <li>The merchant makes an API-call to this method and receives an {@link RegisterAccountResponseData#getAccountId()} in response. </li>
   *   <li>The merchant saves the {@code accountid} as a valid payout option for the end user.</li>
   *   <li>
   *     When it's time to actually do a payout the merchant makes an API-call to
   *     {@link TrustlyApiClient#accountPayout} with the {@link AccountPayoutRequestData#setAmount},
   *     {@link AccountPayoutRequestData#setCurrency} and saved {@link RegisterAccountResponseData#getAccountId()}.
   *   </li>
   * </ol>
   * Multiple calls to this method with the same bank account details will result in the same {@link RegisterAccountResponseData#getAccountId()} being returned.
   */
  public registerAccount(request: RegisterAccountRequestData| null):  RegisterAccountResponseData | null {
    return this.sendRequest(request, RegisterAccountResponseData.class, "RegisterAccount", null);
  }

  public registerAccountPayout(request: RegisterAccountPayoutRequestData| null):  RegisterAccountPayoutResponseData | null {
    return this.sendRequest(request, RegisterAccountPayoutResponseData.class, "RegisterAccountPayout", null);
  }

  public settlementReport(request: SettlementReportRequestData| null):  SettlementReportResponseData | null {
    return this.sendRequest(
      request, SettlementReportResponseData.class, "ViewAutomaticSettlementDetailsCSV", null
    );
  }

  /**
   * Initiates a new withdrawal, returning the URL where the end-user can complete the withdrawal process.
   * <p>
   * You can find more information about how to display the Trustly URL <a href="https://eu.developers.trustly.com/doc/docs/presentation-of-trustly-url">here</a>.
   * <p>
   * A typical withdrawal flow is:
   *
   * <ol>
   *   <li>The merchant sends a Withdraw API call and receives a {@link WithdrawResponseData#getUrl()} back from Trustly's API.</li>
   *   <li>The merchant displays {@link WithdrawResponseData#getUrl()} to the end-user (you can find more information about how to display it <a href="https://eu.developers.trustly.com/doc/docs/presentation-of-trustly-url">here</a>).</li>
   *   <li>
   *     <span>The end-user selects the amount to withdraw and provides his/her bank account details.</span>
   *     <ul>
   *       <li>If the Withdrawal process is not completed, a {@link NotificationRequest}&lt;{@link CancelNotificationData}&gt; is sent.</li>
   *     </ul>
   *   </li>
   *   <li>
   *     <span>
   *       When the end-user has completed the withdrawal process using the {@link WithdrawResponseData#getUrl()},
   *       Trustly sends a {@link NotificationRequest}&lt;{@link DebitNotificationData}&gt; to {@link WithdrawRequestData#getNotificationUrl()}.
   *       The merchant should try to deduct the specified {@link DebitNotificationData#getAmount()} from the end-user's balance in the merchant's system.
   *      </span>
   *     <ul>
   *       <li>If the merchant is able to deduct {@link DebitNotificationData#getAmount()} from the user's balance, the debit notification response should be sent with {@code "status": "OK"}.</li>
   *       <li>
   *         If the merchant is NOT able to deduct {@link DebitNotificationData#getAmount()} from the user's balance, the debit notification response should be sent with {@code "status": "FAILED"}.
   *         The withdrawal is then aborted on Trustly's side and an error message is shown to the end-user. A {@link NotificationRequest}&lt;{@link CancelNotificationData}&gt; is sent to the merchant.
   *       </li>
   *     </ul>
   *   </li>
   *   <li>
   *     (Optional) An {@link NotificationRequest}&lt;{@link AccountNotificationData}&gt; is sent to provide the merchant with more information about the account that was selected by the end user.
   *     This notification is not enabled by default, please reach out to your Trustly contact if you want to receive it.
   *     This information can be used by the merchant to determine if the Withdrawal should be approved or not (see next step).
   *   </li>
   *   <li>
   *     <span>
   *       If manual approval is required, Trustly does nothing with the withdrawal request until it has been approved or denied by the merchant with {@link TrustlyApiClient#approveWithdrawal} / {@link TrustlyApiClient#denyWithdrawal}.
   *       (it is also possible for the merchant to approve or deny the withdrawal in Trustly's backoffice).
   *       Auto-approval can be enabled if requested.
   *     </span>
   *     <ul>
   *       <li>If {@link TrustlyApiClient#denyWithdrawal} is sent, the withdrawal is aborted on Trustly's side and a {@link NotificationRequest}&lt;{@link CancelNotificationData}&gt; and {@link NotificationRequest}&lt;{@link CreditNotificationData}&gt; is sent to the merchant.</li>
   *     </ul>
   *   </li>
   *   <li>If the Withdrawal is approved, Trustly will process the withdrawal.</li>
   *   <li>
   *     (Optional) A {@link NotificationRequest}&lt;{@link PayoutConfirmationNotificationData}&gt; is sent to the merchant when the transfer has been confirmed.
   *     Note: this notification is not enabled by default. Please speak to your Trustly contact if you want to have it enabled.
   *   </li>
   *   <li>If the withdrawal fails, Trustly will send a {@link NotificationRequest}&lt;{@link CreditNotificationData}&gt; notification and a {@link NotificationRequest}&lt;{@link CancelNotificationData}&gt;
   *   (see more details <a href="https://eu.developers.trustly.com/doc/docs/withdraw#failed-withdrawals">here</a>).</li>
   * </ol>
   */
  public withdraw(request: WithdrawRequestData| null):  WithdrawResponseData | null {
    return this.sendRequest(request, WithdrawResponseData.class, "Withdraw", null);
  }

  // Notifications

  /**
   * Add a custom listener for a certain notification type.
   * <p>
   * This method should only be used if there is no existing {@code addOnXyzListener} method for the notification you want.
   */
  public addNotificationListener <D extends IFromTrustlyRequestData>(method: string| null, dataClass: java.lang.Class<D>| null,
    listener: NotificationEvent<D>| null):  void {

    let  meta: TrustlyApiClient.NotificationMeta<D> =  this.onNotification.computeIfAbsent(method, k => new  TrustlyApiClient.NotificationMeta(dataClass)) as TrustlyApiClient.NotificationMeta<D>;
    if (!meta.getDataClass().equals(dataClass)) {
      throw new  java.lang.IllegalArgumentException(
        string.format("Each notification method must be registered with the same type (%s vs %s)", dataClass, meta.getDataClass()));
    }

    meta.getListeners().add(listener);
  }

  public addOnAccountListener(listener: NotificationEvent<AccountNotificationData>| null):  void {
    this.addNotificationListener("account", AccountNotificationData.class, listener);
  }

  public addOnCancelListener(listener: NotificationEvent<CancelNotificationData>| null):  void {
    this.addNotificationListener("cancel", CancelNotificationData.class, listener);
  }

  public addOnCreditListener(listener: NotificationEvent<CreditNotificationData>| null):  void {
    this.addNotificationListener("credit", CreditNotificationData.class, listener);
  }

  public addOnDebitListener(listener: NotificationEvent<DebitNotificationData>| null):  void {
    this.addNotificationListener("debit", DebitNotificationData.class, listener);
  }

  public addOnPayoutConfirmation(listener: NotificationEvent<PayoutConfirmationNotificationData>| null):  void {
    this.addNotificationListener("payoutconfirmation", PayoutConfirmationNotificationData.class, listener);
  }

  public addOnPending(listener: NotificationEvent<PendingNotificationData>| null):  void {
    this.addNotificationListener("pending", PendingNotificationData.class, listener);
  }

  public addOnUnknownNotification(listener: NotificationEvent<UnknownNotificationData>| null):  void {
    this.addNotificationListener("", UnknownNotificationData.class, listener);
  }

  // Base functionality

  /**
   * Used internally to create a request package. You usually do not need to directly call this method unless you are creating a custom
   * request that exist in the documentation but not as a managed type in this class.
   *
   * @param requestData The request data that will be used for the request
   * @param method      The method of the JsonRpc package
   * @param uuid        The UUID for the message, if null one will be generated for you.
   * @param <T>         The type of the request data
   * @return The JsonRpc response data
   * @throws TrustlyValidationException Thrown if the request does not pass proper validations
   */
  public createRequestPackage <T extends IRequestParamsData>(
    requestData: T| null,
    method: string| null,
    uuid: string| null
  ):  JsonRpcRequest<T> | null {

    let  rpcRequest: JsonRpcRequest<T> = this.objectFactory.create(requestData, method, uuid);
    let  signedRpcRequest: JsonRpcRequest<T> = this.signer.sign(rpcRequest);

    this.validator.validate(signedRpcRequest);

    return signedRpcRequest;
  }

  /**
   * Used internally to create a response package.
   *
   * @param method       The method of the JsonRpc package
   * @param uuid         The UUID for the message, if null one will be generated for you
   * @param responseData The response data that was received remotely
   * @param <R>          The type of the response data
   * @return A signed and validated JsonRpc response package
   * @throws TrustlyValidationException Thrown if the response does not pass proper validations
   */
  public createResponsePackage <R extends IResponseResultData>(
    method: string| null,
    uuid: string| null,
    responseData: R| null
  ):  JsonRpcResponse<R> | null {

    let  rpcResponse: JsonRpcResponse<R> = JsonRpcResponse.<R>builder()
      .version("1.1")
      .result(
        ResponseResult.<R>builder()
          .data(responseData)
          .method(method)
          .uuid(uuid)
          .build()
      )
      .build();

    let  signedResponse: JsonRpcResponse<R> = this.signer.sign(rpcResponse);

    this.validator.validate(signedResponse);

    return signedResponse;
  }

  /**
   * Manually send a request to Trustly with the specified data and method and uuid.
   * <p>
   * Should only be used if you need to call an undocumented/newly released method that is not yet added to this library.
   */
  public sendRequest <T extends IToTrustlyRequestParams, R extends IResponseResultData>(
    requestData: T| null,
    clazz: java.lang.Class<R>| null,
    method: string| null,
    uuid: string| null
  ):  R | null {

    try {
      return this.sendRequestWithSpecificExceptions(requestData, clazz, method, uuid);
    } catch (e) {
if (e instanceof java.io.IOException || e instanceof TrustlyValidationException || e instanceof TrustlyErrorResponseException || e instanceof TrustlyRejectionException || e instanceof TrustlySignatureException) {

      throw new  TrustlyRequestException(e);
    } else {
	throw e;
	}
}
  }

  /**
   * Sends given request to Trustly.
   *
   * @param requestData Request to send to Trustly API
   * @param clazz       Type of the JsonRpc response data
   * @param method      The RPC method name of the request
   * @param uuid        Optional UUID for the request. If not specified, one will be generated
   * @param <T>         The outgoing JsonRpc request data type
   * @param <R>         The expected JsonRpc response data type
   * @return Response generated from the request
   * @throws IOException                   If the remote end could not be contacted
   * @throws TrustlyErrorResponseException If the response from Trustly contains an error body
   * @throws TrustlyRejectionException     If the request was rejected by Trustly from their server
   * @throws TrustlySignatureException     If the signature of the request or response could not be verified
   * @throws TrustlyValidationException    If the request or response could not be properly validated
   */
  private sendRequestWithSpecificExceptions <T extends IToTrustlyRequestParams, R extends IResponseResultData>(
    requestData: T| null,
    clazz: java.lang.Class<R>| null,
    method: string| null,
    uuid: string| null
  ):  R | null {

    requestData.setUsername(this.settings.getUsername());
    requestData.setPassword(this.settings.getPassword());

    let  rpcRequest: JsonRpcRequest<T> = this.createRequestPackage(requestData, method, uuid);

    let  requestString: string = this.objectMapper.writeValueAsString(rpcRequest);

    let  responseString: string = this.httpRequester.request(this.settings, requestString);

    let  rpcNodeResponse: JsonNode = this.objectMapper.readTree(responseString);
    let  javaResponseType: JavaType = this.objectMapper.getTypeFactory().constructParametricType(JsonRpcResponse.class, clazz);
    let  rpcResponse: JsonRpcResponse<R> = this.objectMapper.readValue(responseString, javaResponseType);

    TrustlyApiClient.assertSuccessful(rpcResponse);
    TrustlyApiClient.assertWithoutRejection(rpcResponse);

    this.signer.verify(rpcResponse, rpcNodeResponse);

    if (TrustlyStringUtils.isBlank(rpcResponse.getUUID()) || !rpcResponse.getUUID().equals(rpcRequest.getParams().getUuid())) {
      throw new  TrustlyValidationException(
        string.format("Incoming UUID is not valid. Expected %s but got back %s", rpcRequest.getParams().getUuid(), rpcResponse.getUUID())
      );
    }

    return rpcResponse.getResult().getData();
  }

  private static assertWithoutRejection <R extends IResponseResultData>(rpcResponse: JsonRpcResponse<R>| null):  void {

    if (rpcResponse.getResult().getData() instanceof IWithRejectionResult) {
      let  rejectionResult: IWithRejectionResult =  rpcResponse.getResult().getData() as IWithRejectionResult;

      if (!rejectionResult.isResult()) {

        let  message: string = rejectionResult.getRejected();
        if (TrustlyStringUtils.isBlank(message)) {
          message = "The request was rejected for an unknown reason";
        }

        throw new  TrustlyRejectionException(
          "Received a rejection response from the Trustly API: " + message,
          rejectionResult.getRejected()
        );
      }
    }
  }

  private static assertSuccessful <R extends IResponseResultData>(rpcResponse: JsonRpcResponse<R>| null):  void {

    if (!rpcResponse.isSuccessfulResult()) {

      let  message: string = null;
      if (rpcResponse.getError() !== null) {
        message = rpcResponse.getError().getMessage();
        if (TrustlyStringUtils.isBlank(message)) {
          message = rpcResponse.getError().getName();
          if (TrustlyStringUtils.isBlank(message)) {
            message = ("" + rpcResponse.getError().getCode());
          }
        }
      }

      throw new  TrustlyErrorResponseException(string.format("Received an error response from the Trustly API: %s", message), null,
                                              rpcResponse.getError()
      );
    }
  }

  /**
   * Will deserialize, verify and validate the incoming payload for you.
   * <p>
   * It will then call the appropriate notification listeners for this client only. If the incoming notification method does not have a
   * listener, the {@code Unknown} notification listener will be called.
   * <p>
   * It is up to your listener to call the appropriate {@link NotificationArgs#respondWithOk()} or
   * {@link NotificationArgs#respondWithFailed} methods, which will callback to your here given {@code onOK} or {@code onFailed} arguments.
   * <p>
   * It is recommended to <strong>not use this method directly</strong> if possible, and instead use
   * {@link TrustlyApiClientExtensions#handleNotificationRequest} which will call all registered {@link TrustlyApiClient} notification
   * listeners, and handle the servlet request reading and response writing.
   * <p>
   * If you want to handle the reading and writing yourself, then call this method from your own controller or servlet to help with the
   * handling of an incoming notification.
   *
   * @param jsonString The incoming notification as a JSON string
   * @param onOK The callback which will be executed if a listener calls {@link NotificationArgs#respondWithOk()}.
   * @param onFailed The callback which will be executed if a listener calls {@link NotificationArgs#respondWithFailed(String)}.
   *
   * @throws IOException If the JSON string could not be deserialized or the response could not be sent.
   * @throws TrustlyNoNotificationListenerException If there was no listener for the notification, nor one for unknown ones.
   * @throws TrustlyValidationException If the response data could not be properly validated.
   * @throws TrustlySignatureException If the signature of the response could not be properly verified.
   */
  public handleNotification(
    jsonString: string| null,
    onOK: NotificationOkHandler| null,
    onFailed: NotificationFailHandler| null
  ):  void;

  private handleNotification <D extends IFromTrustlyRequestData>(
    jsonString: string| null,
    meta: TrustlyApiClient.NotificationMeta<D>| null,
    onOK: NotificationOkHandler| null,
    onFailed: NotificationFailHandler| null
  ):  void;
public handleNotification(...args: unknown[]):  void {
		switch (args.length) {
			case 3: {
				const [jsonString, onOK, onFailed] = args as [string, NotificationOkHandler, NotificationFailHandler];



    let  jsonToken: JsonNode = this.objectMapper.readTree(jsonString);
    let  methodValue: string = jsonToken.at("/method").asText("").toLowerCase(java.util.Locale.ROOT);

    let  mapper: TrustlyApiClient.NotificationMeta< IFromTrustlyRequestData> = this.onNotification.get(methodValue);

    if (mapper === null || mapper.getListeners().isEmpty()) {
      java.lang.Math.log.warn(string.format("There is no listener for incoming notification '%s'. Will fallback on 'unknown' listener", methodValue));
      mapper = this.onNotification.get("");
      if (mapper === null || mapper.getListeners().isEmpty()) {
        throw new  TrustlyNoNotificationListenerException(string.format("There is no listener for incoming notification '%s' nor unknown", methodValue));
      }
    }

    this.handleNotification(jsonString, mapper, onOK, onFailed);
  

				break;
			}

			case 4: {
				const [jsonString, meta, onOK, onFailed] = args as [string, TrustlyApiClient.NotificationMeta<D>, NotificationOkHandler, NotificationFailHandler];



    let  javaRequestType: JavaType = this.objectMapper.getTypeFactory().constructParametricType(NotificationRequest.class, meta.getDataClass());
    let  rpcRequest: NotificationRequest<D> = this.objectMapper.readValue(jsonString, javaRequestType);

    // Verify the notification (RpcRequest from Trustly) signature.
    try {
      this.signer.verify(rpcRequest);
    } catch (ex) {
if (ex instanceof TrustlySignatureException) {
      throw new  TrustlySignatureException(
        "Could not validate signature of notification from Trustly. Is the public key for Trustly the correct one, for test or production?",
        ex
      );
    } else {
	throw ex;
	}
}

    // Validate the incoming request instance.
    // Most likely this will do nothing, since we are lenient on things sent from Trustly server.
    // But we do this in case anything is needed to be validated on the local domain classes in the future.
    this.validator.validate(rpcRequest);

    let  args: NotificationArgs<D> = new  NotificationArgs(
      rpcRequest.getParams().getData(),
      rpcRequest.getMethod(),
      rpcRequest.getParams().getUuid(),
      onOK, onFailed
    );

    try {

      for (let listener of meta.getListeners()) {
        listener.onNotification(args);
      }
    } catch (ex) {
if (ex instanceof java.lang.Exception) {
      let  message: string = this.settings.isIncludeExceptionMessageInNotificationResponse() ? ex.getMessage() : null;
      onFailed.handle(rpcRequest.getMethod(), rpcRequest.getParams().getUuid(), message);
    } else {
	throw ex;
	}
}
  

				break;
			}

			default: {
				throw new java.lang.IllegalArgumentException(S`Invalid number of arguments`);
			}
		}
	}

}

// eslint-disable-next-line @typescript-eslint/no-namespace, no-redeclare
export namespace TrustlyApiClient {
	export type NotificationMeta<DextendsIFromTrustlyRequestData> = InstanceType<typeof TrustlyApiClient.NotificationMeta<DextendsIFromTrustlyRequestData>>;
}


